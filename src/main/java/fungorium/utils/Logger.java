package fungorium.utils;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Logger {
    private Logger() {
        throw new UnsupportedOperationException("Logger is a static utility class and cannot be instantiated.");
    }

    // Map to store created objects and their generated names.
    private static Map<Object, String> objectNames = new HashMap<>();
    // Map to keep counters for each unique prefix.
    private static final Map<String, Integer> prefixCounters = new HashMap<>();
    // Map to store already computed unique prefixes for classes.
    private static final Map<Class<?>, String> computedPrefixes = new HashMap<>();
    // Current indentation level.
    private static int indentLevel = 0;
    // Indentation unit (e.g., 4 spaces).
    private static final String INDENT_UNIT = "    ";

    private static Scanner scanner = new Scanner(System.in);

    /**
     * Creates a name for the given object and stores it.
     * The name is generated by obtaining a unique prefix for the object's class.
     * If the simple name of the class ends with an existing class's simple name,
     * then the prefix of that existing class is reused.
     * The final name is the prefix concatenated with a counter from prefixCounters.
     * For example, if Tecton was created first, its name might be "t1".
     * If Thread is created next, its name might be "th1".
     * Then, if a class like ThreadAbsorbertecton is created (its simple name ending
     * with "tecton"),
     * it reuses Tectonâ€™s prefix and will be named "t2".
     */
    public static void create(Object obj) {
        if (obj == null) {
            return;
        }
        Class<?> clazz = obj.getClass();
        String prefix = getUniquePrefix(clazz);
        int count = prefixCounters.getOrDefault(prefix, 0) + 1;
        prefixCounters.put(prefix, count);
        String name = prefix + count;
        objectNames.put(obj, name);
        enter(null, clazz.getSimpleName());
        System.out.println(getIndent() + name + " created");
        exit("");
    }

    /**
     * Computes a unique prefix for the given class based on its simple name.
     * If another class has already been assigned a prefix that would conflict (i.e.
     * they share the same initial letters),
     * this method increases the number of letters used until the prefixes are
     * distinct.
     */
    /**
     * Computes a unique prefix for the given class.
     * If the class's simple name ends with the simple name of any class already in
     * computedPrefixes,
     * then that existing class's prefix is reused.
     * Otherwise, the prefix is computed by taking an increasing substring of the
     * class's simple name
     * until no conflict is found.
     */
    private static String getUniquePrefix(Class<?> clazz) {
        if (computedPrefixes.containsKey(clazz)) {
            return computedPrefixes.get(clazz);
        }
        String fullName = clazz.getSimpleName().toLowerCase();
        // First, check if fullName ends with any previously registered class's simple
        // name.
        for (Map.Entry<Class<?>, String> entry : computedPrefixes.entrySet()) {
            String existingSimpleName = entry.getKey().getSimpleName().toLowerCase();
            if (fullName.endsWith(existingSimpleName)) {
                String prefix = entry.getValue();
                computedPrefixes.put(clazz, prefix);
                return prefix;
            }
        }
        // If no matching suffix is found, compute a new unique prefix.
        int candidateLength = 1;
        String candidate = fullName.substring(0, candidateLength);
        boolean unique;
        do {
            unique = true;
            for (Map.Entry<Class<?>, String> entry : computedPrefixes.entrySet()) {
                String otherPrefix = entry.getValue();
                if (otherPrefix.equals(candidate)) {
                    unique = false;
                    break;
                }
            }
            if (!unique) {
                candidateLength++;
                candidate = fullName.substring(0, candidateLength);
            }
        } while (!unique);
        computedPrefixes.put(clazz, candidate);
        return candidate;
    }

    /**
     * Logs the entering of a function by printing an indented line
     * with the function name and "()" preceded by "-->".
     * Then increases the indentation for nested calls.
     */
    public static void enter(Object clazz, String functionName) {
        if (clazz == null){
            System.out.println(getIndent() + "--> " + functionName + "()");
        }
        else{
            System.out.println(getIndent() + "--> " + objectNames.get(clazz) + "." + functionName + "()");
        }
        indentLevel++;
    }

    /**
     * Logs the exit of a function by decreasing the indentation level
     * and printing an indented line with "<--". If a return value is provided,
     * and it is an object that has been registered, its generated name is printed.
     * Otherwise, the return value's toString() is used.
     */
    public static void exit(Object returnValue) {
        indentLevel = Math.max(0, indentLevel - 1);
        String retStr = "";
        if (returnValue != null) {
            if (objectNames.containsKey(returnValue)) {
                retStr = objectNames.get(returnValue);
            } else {
                retStr = returnValue.toString();
            }
        }
        System.out.println(getIndent() + "<--" + (retStr.isEmpty() ? "" : " " + retStr));
    }

    /**
     * Asks the user a yes/no question (provided in questionText) using the current
     * indentation.
     * Re-prompts if the answer is not "y" or "n".
     * Returns true for "y" and false for "n".
     */
    public static boolean question(String questionText) {
        System.out.print(getIndent() + questionText + " (y/n): ");
        String input = scanner.nextLine().trim().toLowerCase();
        while (!input.equals("y") && !input.equals("n")) {
            System.out.print(getIndent() + "Please answer with y/n: ");
            input = scanner.nextLine().trim().toLowerCase();
        }
        return input.equals("y");
    }

    /**
     * Helper method to build the current indent string.
     */
    private static String getIndent() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < indentLevel; i++) {
            sb.append(INDENT_UNIT);
        }
        return sb.toString();
    }
}
